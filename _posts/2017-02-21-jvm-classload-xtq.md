---
layout: 	post
title: 		"Java的类加载过程"
subtitle:	"A class will be loaded when necessary!"
date: 		2017-2-21 18:47:00
author: 	"玄天强"
header-img:	"img/classload-bg-xtq.jpg"
catalog: true
tags:
	- Jvm
	- Java Advanced
---



#类加载
____

##1.类的生命周期
	
	加载——>验证——>准备——>解析——>初始化——>使用——>卸载

	//解析的过程可能在初始化之后

##2.加载时机

*	(1)加载时机并未作规定，由虚拟机自己把握	
*	(2)初始化只且只在以下五种情况进行:

		a.new：实例化对象时
		  getstatic、 putstatic： 读取或设置静态字段 
		  invokestatic:调用静态方法 
		  若未初始化，须先初始化
		b.类进行反射调用时
		c.初始化一个类时，若其父类未初始化，先初始化其父类
		d.虚拟机启动时，先初始化包含main的主类
		e.JDK1.7中的动态语言支持	

*	(3)以上五种情况称为**主动引用**，其他都为被动引用，不会引发初始化。

##3.加载

*	所完成的工作：
	
		(1)	获取定义此类的二进制字节流--通过类的全限定名
		(2) 将该字节流所代表的静态存储结构转为方法区的运行时数据结构
		(3) 生成Class对象

*	二进制流来源：	Zip包(jar,war)、网络(Applet)、运行时生成(动态代理)、其他文件(JSP)、数据库...
*	加载阶段可控性最强，可用系统的引导类加载器完成，也可用自定义类加载器完成。
*	数组类的创建:
	
		(1)数组类本身不是由类加载器创建，而是由Java虚拟机直接创建
		(2)数组元素的类型需用类加载器创建

*	完成后:

		(1)二进制流按一定格式存储在方法区，格式与具体实现相关
		(2)在内存中实例化一个Class对象，HotSpot中，该对象在方法区，不在堆中

##4.验证

*	四个动作：	文件格式验证--元数据验证--字节码验证--符号引用验证
*	文件格式验证：

		(1)字节流是否符合Class文件格式的规范
		(2)保证输入的字节流能正确解析并存储于方法区之内，格式上符合一个Java类型信息的要求。
		(3)基于字节流进行验证，之后的验证才是基于方法区的存储结构

*	元数据验证:

		(1)对字节码描述的信息进行语义分析
		(2)保证其描述的信息符合Java语言规范的要求

*	字节码验证：

		(1)确定语义是合法的、符合逻辑的
		(2)对类的方法体进行校验分析
		(3)如果一个方法体通过了字节码验证，也不一定就是安全的
		(4)Java1.6后，在方法体的Code属性中加入了"StackMapTable"属性来优化，将字节码验证类型推导转变为类型检查
		(5)Java1.7后，使用类型检查来完成数据流分析校验是唯一的选择

*	符合引用验证:

		(1)在将符号引用转化为直接引用时进行
		(2)在解析阶段发生,确保解析动作能正常进行
		(3)对类自身以外的信息进行匹配性校验
		(4)很重要但不是必要的
		
##5.准备

*	正式为类变量(static)分配内存并设置类变量初始值
*	内存在方法区进行分配
*	初始值为数据类型的零值
*	类字段的字段属性表中存在ConstantValue时，准备阶段被初始化为ConstantValue属性所指定的值


##6.解析
*	将常量池中的符合引用替换为直接引用
*	符合引用：

		(1)以一组符合来描述所引用的目标
		(2)可以是任何形式的字面量
		(3)与虚拟机实现的内存布局无关，引用的目标并不一定已加载到内存中 

*	直接引用：
		
		(1)	可以是指针，相对偏移量(直接指向目标)，或是句柄(间接指向目标)
		(2)与虚拟机实现的内存布局相关
		(3)有直接引用，引用的目标必定已经在内存中存在

*	解析阶段的具体时间未做规定，但在16个用于操作符号引用的字节码指令之前，先对它们使用的符合引用进行解析。
*	虚拟机保证了在同一个实体中，如果一个符合引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功。
*	对ivokedynamic指令是例外，它对应的引用称为"动态调用点限定符"，必须等到程序实际运行到这条指令时才进行解析
*	解析主要针对七类符号引用进行:

		(1)类或接口
		(2)字段
		(3)类方法
		(4)接口方法
		(5)方法类型
		(6)方法句柄
		(7)调用点限定符

##6.初始化
*	根据程序员通过程序制定的主观计划初始化类变量和其他资源
*	执行类构造器<clinit>()方法
*	<clinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的

		(1)静态语句块只能访问到定义在它之前的变量，定义在它后面的变量只能赋值，不能访问
		(2)<clinit>()方法不需要显示调用父类构造器
		(3)父类中定义的静态块优先于子类的变量赋值操作
		(4)对类或接口并不是必须的,没有静态块语句，也没有对变量的赋值操作时
		(5)接口中也会有变量初始化的赋值操作，也会生成<clinit>()方法
		(6)执行接口的该方法不需要先执行父接口的该方法，其实现类在初始化时也不会执行接口的<clinit>()方法。
		(7)虚拟机暴走一个类的<clinit>方法在多线程环境中被正确地加锁、同步
